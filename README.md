# 16-bit-Harvard-Architecture-CPU-Based-on-Verilog-HDL


















A 16-bit Harvard Architecture 
CPU Based on Verilog HDL



Yuelin Deng
06911601
1120160483
February 11,2019

 
1.	Abstract
This paper describes the structure of a 16-bit Harvard Architecture CPU Based on Verilog HDL. Unlike the standard Von Neumann Architecture, this CPU runs a set of 16-bit instruction which is stored in an independent ROM chip. The structure of this CPU is more simplified compared with 8088/8086 CPU, but it is still a general-purpose CPU that can run any code that can be translated into its instruction set. In this design, inputs to and outputs from the computer are assumed to affect the memory directly, without being processed by the CPU. A part of the Memory is specialized to handle inputs and outputs. This paper adopted the bottom-up design method and used mainly the gate description design instead of behavior description.
2.	Overall design
1)	Components

 
Figure 1. Microcomputer design

The key components of the microcomputer are as shown in Figure 1.

The central processing unit (CPU) is the heart of the microcomputer. It takes instructions from the instruction memory, operates according to the instruction, store data according to the instruction and feed the address of the next instruction to the instruction memory.

The control unit consists of a program counter (PC), several multiplexers and registers. The arithmetic/logic unit consists of an arithmetic logic unit (ALU) that can carry out multiple calculations and logic operations.
3.	ALU design
1)	Function description and interface
The ALU (Arithmetic Logic Unit) can computes one of the following functions: x+y, x-y, y-x, 0, 1, -1, x, y, -x, -y, !x, !y, x+1, y+1, x-1, y-1, x&y, x|y on two 16-bit inputs according to 6 input bits denoted zx, nx, zy, ny, f and no.

In addition, the ALU computes two 1-bit outputs: if the ALU output == 0, zr is set to 1; otherwise zr is set to 0; if the ALU output < 0, ng is set to 1; otherwise ng is set to 0.

The ALU always operates on signed 2's complement. The MSB of the 16-bit input and output is sign-bit, overflow is neglected when it occurs during addition process.

To implement this set of functions, the operation are as follows:
a)	if (zx == 1) set x = 0			// 16-bit constant
b)	if (nx == 1) set x = !x			// bitwise not
c)	if (zy == 1) set y = 0			// 16-bit constant
d)	if (ny == 1) set y = !y			// bitwise not
e)	if (f == 1) set out = x + y		// integer 2's complement addition
f)	if (f == 0) set out = x & y		// bitwise and
g)	if (no == 1) set out = !out		// bitwise not
h)	if (out == 0) set zr = 1
i)	if (out < 0) set ng = 1

The interface of the ALU is shown in Figure 2.

 
Figure 2. ALU interface
2)	Function truth table
Table 1 Truth table of ALU
zx	nx	zy	ny	f	no	out
1	0	1	0	1	0	0
1	1	1	1	1	1	1
1	1	1	0	1	0	-1
0	0	1	1	0	0	x
1	1	0	0	0	0	y
0	0	1	1	0	1	!x
1	1	0	0	0	1	!y
0	0	1	1	1	1	-x
1	1	0	0	1	1	-y
0	1	1	1	1	1	x+1
1	1	0	1	1	1	y+1
0	0	1	1	1	0	x-1
1	1	0	0	1	0	y-1
0	0	0	0	1	0	x+y
0	1	0	0	1	1	x-y
0	0	0	1	1	1	y-x
0	0	0	0	0	0	x&y
0	1	0	1	0	1	x|y
Exmple 1: 134+283 = 417
The op-code is zx=0, nx=0, zy=0, ny=0, f=1, no=0, 
so only addition is conducted.
In 2's complement: 0000000010000110 + 0000000100011011 = 0000000110100001

Example 2: 235 - 834 = -599
The op-code is zx=0, nx=1, zy=0, ny=0, f=1, no=1,
x = !x: 0000000011101011 -> 1111111100010100
!x + y: 1111111100010100 + 0000001101000010 = 0000001001010110
!(!x + y): 0000001001010110 -> 1111110110101001, which is -599 in 2's complement.

Example 3: -(9434) = -9434
The op-code is zx=0, nx=0, zy=1, ny=1, f=1, no=1,
set y = 1111111111111111
x + y: 0010010011011010 + 1111111111111111 = 0010010011011001
!(x + y): 0010010011011001->1101101100100110, which is -9434 in 2's complement.






3)	HDL implementation
HDL code
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
module ALU(x,y,zx,nx,zy,ny,f,no,out,zr,ng);

input [15:0] x,y;
input zx,nx,zy,ny,f,no;
output [15:0] out;
output zr,ng;

supply0 [15:0] false;
wire [15:0] x1,nx1,x2;
wire [15:0] y1,ny1,y2;
wire [15:0] o1,o2,o3,no3,o4;
wire o5;

Mux16 mux1(.a(x),.b(false),.sel(zx),.out(x1));
Not16 not1(.out(nx1),.in(x1));
Mux16 mux2(.a(x1),.b(nx1),.sel(nx),.out(x2));

Mux16 mux3(.a(y),.b(false),.sel(zy),.out(y1));
Not16 not2(.out(ny1),.in(y1));
Mux16 mux4(.a(y1),.b(ny1),.sel(ny),.out(y2));

Add16 add(.a(x2),.b(y2),.out(o1));
And16 and1(.out(o2),.a(x2),.b(y2));

Mux16 mux5(.a(o2),.b(o1),.sel(f),.out(o3));

Not16 not3(.out(no3),.in(o3));
Mux16 mux6(.a(o3),.b(no3),.sel(no),.out(o4));
assign out = o4;

Or16Way or1(.in(o4),.out(o5));
Not16 not4(.out(zr),.in(o5));

assign ng = o4[15];

endmodule
RTL schematic
The RTL schematic generated by ISE is shown in Figure 3 and Figure 4.
 
Figure 3. RTL interface of ALU

 
Figure 4. RTL implementation of ALU
4)	Simulation
A segment of the testbench code:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
`timescale 1ns / 1ps
 
module Test_ALU;

    // Inputs
    reg [15:0] x;
    reg [15:0] y;
    reg zx;
    reg nx;
    reg zy;
    reg ny;
    reg f;
    reg no;

    // Outputs
    wire [15:0] out;
    wire zr;
    wire ng;

    // Instantiate the Unit Under Test (UUT)
    ALU uut (
        .x(x), 
        .y(y), 
        .zx(zx), 
        .nx(nx), 
        .zy(zy), 
        .ny(ny), 
        .f(f), 
        .no(no), 
        .out(out), 
        .zr(zr), 
        .ng(ng)
    );

    initial begin
        // Initialize Inputs
        
        #100;
        x = 16'b0000000000010001;
        y = 16'b0000000000000011;
        {zx,nx,zy,ny,f,no} = 6'b001111;
        #100;
        x = 16'b0000000000010001;
        y = 16'b0000000000000011;
        {zx,nx,zy,ny,f,no} = 6'b110011;
        #100;
        x = 16'b0000000000010001;
        y = 16'b0000000000000011;
        {zx,nx,zy,ny,f,no} = 6'b011111;
        #100;
        x = 16'b0000000000010001;
        y = 16'b0000000000000011;
        {zx,nx,zy,ny,f,no} = 6'b110111;
        #100;
        x = 16'b0000000000010001;
        y = 16'b0000000000000011;
        {zx,nx,zy,ny,f,no} = 6'b001110;
        #100;
        x = 16'b0000000000010001;
        y = 16'b0000000000000011;
        {zx,nx,zy,ny,f,no} = 6'b110010;
        #100;
        x = 16'b0000000000010001;
        y = 16'b0000000000000011;
        {zx,nx,zy,ny,f,no} = 6'b010011;
        #100;
        
        // Wait 100 ns for global reset to finish
        
        
        // Add stimulus here

    end
      
endmodule

The wave form of the simulation result is shown in Figure 5.

 
Figure 5. ALU simulation result

The output table are as shown in Table 2.

Table 2 Outputs of ALU simulation
x	y	zx	nx	zy	ny	f	no	out	zr	ng
0000000000000000	1111111111111111	1	0	1	0	1	0	0000000000000000	1	0
0000000000000000	1111111111111111	1	1	1	1	1	1	0000000000000001	0	0
0000000000000000	1111111111111111	1	1	1	0	1	0	1111111111111111	0	1
0000000000000000	1111111111111111	0	0	1	1	0	0	0000000000000000	1	0
0000000000000000	1111111111111111	1	1	0	0	0	0	1111111111111111	0	1
0000000000000000	1111111111111111	0	0	1	1	0	1	1111111111111111	0	1
0000000000000000	1111111111111111	1	1	0	0	0	1	0000000000000000	1	0
0000000000000000	1111111111111111	0	0	1	1	1	1	0000000000000000	1	0
0000000000000000	1111111111111111	1	1	0	0	1	1	0000000000000001	0	0
0000000000000000	1111111111111111	0	1	1	1	1	1	0000000000000001	0	0
0000000000000000	1111111111111111	1	1	0	1	1	1	0000000000000000	1	0
0000000000000000	1111111111111111	0	0	1	1	1	0	1111111111111111	0	1
0000000000000000	1111111111111111	1	1	0	0	1	0	1111111111111110	0	1
0000000000000000	1111111111111111	0	0	0	0	1	0	1111111111111111	0	1
0000000000000000	1111111111111111	0	1	0	0	1	1	0000000000000001	0	0
0000000000000000	1111111111111111	0	0	0	1	1	1	1111111111111111	0	1
0000000000000000	1111111111111111	0	0	0	0	0	0	0000000000000000	1	0
0000000000000000	1111111111111111	0	1	0	1	0	1	1111111111111111	0	1
0000000000010001	0000000000000011	1	0	1	0	1	0	0000000000000000	1	0
0000000000010001	0000000000000011	1	1	1	1	1	1	0000000000000001	0	0
0000000000010001	0000000000000011	1	1	1	0	1	0	1111111111111111	0	1
0000000000010001	0000000000000011	0	0	1	1	0	0	0000000000010001	0	0
0000000000010001	0000000000000011	1	1	0	0	0	0	0000000000000011	0	0
0000000000010001	0000000000000011	0	0	1	1	0	1	1111111111101110	0	1
0000000000010001	0000000000000011	1	1	0	0	0	1	1111111111111100	0	1
0000000000010001	0000000000000011	0	0	1	1	1	1	1111111111101111	0	1
0000000000010001	0000000000000011	1	1	0	0	1	1	1111111111111101	0	1
0000000000010001	0000000000000011	0	1	1	1	1	1	0000000000010010	0	0
0000000000010001	0000000000000011	1	1	0	1	1	1	0000000000000100	0	0
0000000000010001	0000000000000011	0	0	1	1	1	0	0000000000010000	0	0
0000000000010001	0000000000000011	1	1	0	0	1	0	0000000000000010	0	0
0000000000010001	0000000000000011	0	0	0	0	1	0	0000000000010100	0	0
0000000000010001	0000000000000011	0	1	0	0	1	1	0000000000001110	0	0
0000000000010001	0000000000000011	0	0	0	1	1	1	1111111111110010	0	1
0000000000010001	0000000000000011	0	0	0	0	0	0	0000000000000001	0	0
0000000000010001	0000000000000011	0	1	0	1	0	1	0000000000010011	0	0
4.	CPU design
1)	Function description and interface
The CPU is a 16-bit processor designed to execute the current instruction and figure out which instruction to execute next. (Instructions are stored in the instruction memory and cannot be changed by the CPU)

According to the function description, we have the CPU interface as follows in Figure 6.

 
Figure 6. CPU interface

Here, the three inputs, inM is the input from the data memory, instruction is from the instruction memory, reset is from outside the computer and CLK is a stable given clock singnal. The four outputs, outM is the output to the data memory, writeM is the load signal for the data memory, addressM is the address for the selected data register in data memory and pc is the address for the selected instruction memory.
2)	Characteristic
Different to other CPUs, this CPU does NOT have states. At any given time, there is always a selected register in the instruction memory and a selected register in the data memory. Which means that there is always a instruction input, always a data input and data output, always a address output to both data memory and instruction memory. What the CPU do in this clock cycle is entirely decided by the instruction input. Every clock cycle the CPU executes an instruction and feed out the address for the next instruction.
3)	Internal components and its HDL implementation
The CPU consists of the following components, multiplexer, A-register, D-register, ALU, program counter and jump logic unit.

The ALU is already described and implemented in the previous chapter.

Multiplexer
The multiplexer can control the flow of data according to instruction input.

HDL code:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
module Mux16(a,b,sel,out);

input [15:0] a;
input [15:0] b;
input sel;
output [15:0] out;

reg [15:0] out;

always @ (a,b,sel)
    begin
        case(sel)
        
        1'b0 : out = a;
        1'b1 : out = b;
        endcase
        
    end

endmodule

 
Figure 7. RTL interface of Mux16
Register
The register can store data inside the CPU.

HDL code of 1-bit register:
1
2
3
4
5
6
7
8
9
10
11
12
13
module Bit(in,load,out,CLK);

input in,load,CLK;
output out;

wire out1,out2;
supply1 true;

Mux mux(.a(out1),.b(in),.sel(load),.out(out2));
DFF dff(.D(out2),.CLK(CLK),.Q(out1));
and (out,out1,true);

endmodule

 
Figure 8. RTL implementation of 16-bit registers
Program Counter
The program counter can generate the address of the next instruction according to the current instruction. When load is true, the program counter load the input address. When inc is true, the program counter give out the previous address plus one.

HDL code:
1
2
3
4
5
6
7
8
9
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
module PC(in,load,inc,reset,out,CLK);

input [15:0] in;
input load,inc,reset,CLK;
output [15:0] out;

wire [15:0] back,in1,in2,out1,out2;
supply0 [15:0] false;
supply1 [15:0] true16;
supply1 true;

Mux16 mux1(.a(back),.b(in),.sel(load),.out(in1));
Mux16 mux2(.a(in1),.b(false),.sel(reset),.out(in2));
Register register1(.in(in2),.load(true),.out(out1),.CLK(CLK));
And16 and1(.a(out1),.b(true16),.out(out));
Inc16 inc1(.in(out1),.out(out2));
Mux16 mux3(.a(out1),.b(out2),.sel(inc),.out(back));

endmodule

module Inc16(in,out);

input [15:0] in;
output [15:0] out;

supply0 [14:0] false;
supply1 true;
wire [15:0] b;

assign b = {false,true};


Add16 add16(.a(in),.b(b),.out(out));

endmodule

 
Figure 9. RTL implementation of Program Counter
4)	CPU implementation
 
Figure 10. CPU Structural block diagram

The control pins are linked to logic outputs of the instruction.
5)	HDL code
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
`timescale 1ns / 1ps

module CPU(inM,instruction,reset,outM,writeM,addressM,pc,CLK);

input [15:0] inM,instruction;
input reset,CLK;
output [15:0] outM;
output writeM;
output [14:0] addressM,pc;

wire [15:0] outALU,outMux1,outA,outD,outAM,outPC;
wire loadA,zr,ng,notzr,notng,out1,j1,j2,j3,loadpc1,loadpc;
supply1 true;

and (I0,instruction[15],instruction[0]);
and (I1,instruction[15],instruction[1]);
and (I2,instruction[15],instruction[2]);
and (I3,instruction[15],instruction[3]);
and (I4,instruction[15],instruction[4]);
and (I5,instruction[15],instruction[5]);
and (I12,instruction[15],instruction[12]);

Mux16 mux1(.a(instruction),.b(outALU),.sel(instruction[15]),.out(outMux1));
xnor (loadA,instruction[15],I5);
Register Aregister(.in(outMux1),.load(loadA),.out(outA),.CLK(CLK));
assign addressM = outA[14:0];

Register Dregister(.in(outALU),.load(I4),.out(outD),.CLK(CLK));

Mux16 mux2(.a(outA),.b(inM),.sel(I12),.out(outAM));

ALU alu1(.x(outD),.y(outAM),.zx(instruction[11]),.nx(instruction[10]),.zy(instruction[9]),
    .ny(instruction[8]),.f(instruction[7]),.no(instruction[6]),
    .out(outALU),.zr(zr),.ng(ng));
assign outM = outALU;

assign writeM = I3;

not (notzr,zr);
not (notng,ng);
and (out1,notzr,notng);
and (j3,I0,out1);
and (j2,I1,zr);
and (j1,I2,ng);
assign loadpc1 = |{j1,j2,j3};
and (loadpc,loadpc1,instruction[15]);
PC pc1(.in(outA),.load(loadpc),.reset(reset),.inc(true),.out(outPC),.CLK(CLK));
assign pc = outPC[14:0];


endmodule

 
Figure 10. RTL implementation of CPU
5.	Instruction set
1)	A-instruction
Syntax: SET value
value is a non-negative decimal number or a symbol referring to a constant non-negative decimal number that is less than 2^15-1.

Semantics:
i.	Sets the A register to value.
ii.	RAM[A] becomes the selected RAM register. (addressM is set to be the data in A-register)

Example: SET 21
Effect: A register stores 21, RAM[21] becomes the selected RAM register.
Binary code: SET 21
0	0	0	0	0	0	0	0	0	0	0	1	0	1	0	1
MSB = 0 showing that this is an A-instruction. The following 15-bits are the binary of that non-negative decimal number.
2)	C-instruction
Syntax: dest = comp ; jump
Where comp can be any one of the computations shown in Table 3.
dest = null, M, D, MD, A, AM, AD, AMD
jump = null JGT, JEQ, JGE, JLT, JNE, JLE, JMP
Here, M refers to outM (the output to the data memory from the CPU), D refers to the D-register, while A refers to the A-register.

Semantics: 
i.	Compute the value of comp;
ii.	Stores the result in dest;
iii.	If the Boolean expression (comp jump 0) is true, jumps to execute the instruction stored in ROM[A]. (pc is set to be the data in A-register)
Example: SET RAM[300] to the value of the D register minus 1
SET 300 	//A = 300
M = D - 1	//RAM[300] = D - 1 

Example: If (D – 1 == 0) jump to execute the instruction stored in ROM[56]
SET 56 	//A = 56
D - 1 ; JEQ	//if (D – 1 == 0), pc = A
Binary code: SET 21
1	1	1	a	C1	C2	C3	C4	C5	C6	D1	D2	D3	J1	J2	J3
MSB = 1 showing that this is an C-instruction. The following two bits is not used and set to 1. The next 7 bits are comp bits. Then comes the dest bits. The last 3 bits are jump bits. Mapping of binary code and function are shown in Table 3 to Table 5

Table 3 computation bits mapping.
comp	C1	C2	C3	C4	C5	C6
0		1	0	1	0	1	0
1		1	1	1	1	1	1
-1		1	1	1	0	1	0
D		0	0	1	1	0	0
A	M	1	1	0	0	0	0
!D		0	0	1	1	0	1
!A	!M	1	1	0	0	0	1
-D		0	0	1	1	1	1
-A	-M	1	1	0	0	1	1
D+1		0	1	1	1	1	1
A+1	M+1	1	1	0	1	1	1
D-1		0	0	1	1	1	0
A-1	M-1	1	1	0	0	1	0
D+A	D+M	0	0	0	0	1	0
D-A	D-M	0	1	0	0	1	1
A-D	M-D	0	0	0	1	1	1
D&A	D&M	0	0	0	0	0	0
D|A	D|M	0	1	0	1	0	1
a=0	a=1	
We can see form this table that C1 to C6 is the same as zx to no in the ALU and x=D, while a=0 means that y=A, a=1 means y=M.

Table 4 destination bits mapping
dest	D1	D2	D3	Effect: the value is stored in:
null	0	0	0	The value is not stored
M	0	0	1	RAM[A]
D	0	1	0	D register
MD	0	1	1	RAM[A] and D register
A	1	0	0	A register 
AM	1	0	1	A register and RAM[A]
AD	1	1	0	A register and D register
AMD	1	1	1	A register, RAM[A] and D register
We can see that D1, D2 and D3 can be use as the enable/write pin for A/D register and writeM when the MSB of instruction is 1.

Table 5 jump bits mapping
jump	D1	D2	D3	Effect:
null	0	0	0	No jump
JGT	0	0	1	If out>0 jump
JEQ	0	1	0	If out=0 jump
JGE	0	1	1	If out≥0 jump
JLT	1	0	0	If out<0 jump
JNE	1	0	1	If out≠0 jump
JLE	1	1	0	If out≤0 jump
JMP	1	1	1	Unconditional jump
Here out is the out put of the ALU.

6.	Sample program and simulation
1)	Sample program
The goal of this program is to calculate the value of |496 + 1567 - 3705| and store it in RAM[0].
ROM	Assembly language	Binary Code
0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
SET 496	
D = A		//D = 496
SET 16		
M = D		//RAM[16] = 496
SET 1567	
D = A		//D = 1567
SET 17		
M = D		//RAM[17] = 1567
SET 3705	
D = A		//D = 3705
SET 18		
M = D		//RAM[18] = 3705
SET 16		//load RAM[16]
D = M		//D = 496
SET 17		//load RAM[17]
D = D + M	//D = 496 + 1567
SET 18		//load RAM[18]
D = D - M	//D = 2063 - 3705
SET 24		//set A = 24
D ; JGE	//jump to line 24 if D>0
SET 0		//load RAM[0]
M = -D		//RAM[0] = 1642
SET 22		//end cycle
0 ; JMP	//jump to line 22
SET 0		//load RAM[0]
M = D		//RAM[0] = 1642
SET 22		//set A = 22
0 ; JMP	//jump to line 22	0000000111110000
1110110000010000
0000000000010000
1110001100001000
0000011000011111
1110110000010000
0000000000010001
1110001100001000
0000111001111001
1110110000010000
0000000000010010
1110001100001000
0000000000010000
1111110000010000
0000000000010001
1111000010010000
0000000000010010
1111010011010000
0000000000011000
1110001100000011
0000000000000000
1110001111011000
0000000000010110
1110101010000111
0000000000000000
1110001100011000
0000000000010110
1110101010000111
We can see that a loop is designed to end the program. With out the loop the program counter will continue to read instruction from ROM[28] and beyond causing unexpected errors.
2)	Testbench
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
`timescale 1ns / 1ps
module Test_CPU;

    // Inputs
    reg [15:0] inM;
    reg [15:0] instruction;
    reg reset;
    reg CLK;
    // Outputs
    wire [15:0] outM;
    wire writeM;
    wire [14:0] addressM;
    wire [14:0] pc;

    // Instantiate the Unit Under Test (UUT)
    CPU uut (
        .inM(inM), 
        .instruction(instruction), 
        .reset(reset), 
        .outM(outM), 
        .writeM(writeM), 
        .addressM(addressM), 
        .pc(pc), 
        .CLK(CLK)
    );

    initial begin
        // Initialize Inputs
        inM = 16'b0000000000000000;
        instruction = 16'b0000000111110000;
        reset = 1;
        CLK = 0;
        #50;
        CLK = 1;
        #50;
      //0
        inM = 16'b0000000000000000;
        instruction = 16'b0000000111110000;
        reset = 0;
        CLK = 0;
        #50;
        CLK = 1;
        #50;
        //1
        inM = 16'b0000000000000000;
        instruction = 16'b1110110000010000;
        reset = 0;
        CLK = 0;
        #50;
        CLK = 1;
        #50;
        //2
        inM = 16'b0000000000000000;
        instruction = 16'b0000000000010000;
        reset = 0;
        CLK = 0;
        #50;
        CLK = 1;
        #50;
        //3
        inM = 16'b0000000000000000;
        instruction = 16'b1110001100001000;
        reset = 0;
        CLK = 0;
        #50;
        CLK = 1;
        #50;
        //4
        inM = 16'b0000000000000000;
        instruction = 16'b0000011000011111;
        reset = 0;
        CLK = 0;
        #50;
        CLK = 1;
        #50;
        //5
        inM = 16'b0000000000000000;
        instruction = 16'b1110110000010000;
        reset = 0;
        CLK = 0;
        #50;
        CLK = 1;
        #50;
        //6
        inM = 16'b0000000000000000;
        instruction = 16'b0000000000010001;
        reset = 0;
        CLK = 0;
        #50;
        CLK = 1;
        #50;
        //7
        inM = 16'b0000000000000000;
        instruction = 16'b1110001100001000;
        reset = 0;
        CLK = 0;
        #50;
        CLK = 1;
        #50;
        //8
        inM = 16'b0000000000000000;
        instruction = 16'b0000111001111001;
        reset = 0;
        CLK = 0;
        #50;
        CLK = 1;
        #50;
        //9
        inM = 16'b0000000000000000;
        instruction = 16'b1110110000010000;
        reset = 0;
        CLK = 0;
        #50;
        CLK = 1;
        #50;
        //10
        inM = 16'b0000000000000000;
        instruction = 16'b0000000000010010;
        reset = 0;
        CLK = 0;
        #50;
        CLK = 1;
        #50;
        //11
        inM = 16'b0000000000000000;
        instruction = 16'b1110001100001000;
        reset = 0;
        CLK = 0;
        #50;
        CLK = 1;
        #50;
        //12
        inM = 16'b0000000111110000;
        instruction = 16'b0000000000010000;
        reset = 0;
        CLK = 0;
        #50;
        CLK = 1;
        #50;
        //13
        inM = 16'b0000000111110000;
        instruction = 16'b1111110000010000;
        reset = 0;
        CLK = 0;
        #50;
        CLK = 1;
        #50;
        //14
        inM = 16'b0000011000011111;
        instruction = 16'b0000000000010001;
        reset = 0;
        CLK = 0;
        #50;
        CLK = 1;
        #50;
        //15
        inM = 16'b0000011000011111;
        instruction = 16'b1111000010010000;
        reset = 0;
        CLK = 0;
        #50;
        CLK = 1;
        #50;
        //16
        inM = 16'b0000111001111001;
        instruction = 16'b0000000000010010;
        reset = 0;
        CLK = 0;
        #50;
        CLK = 1;
        #50;
        //17
        inM = 16'b0000111001111001;
        instruction = 16'b1111010011010000;
        reset = 0;
        CLK = 0;
        #50;
        CLK = 1;
        #50;
        //18
        inM = 16'b0000000000000000;
        instruction = 16'b0000000000011000;
        reset = 0;
        CLK = 0;
        #50;
        CLK = 1;
        #50;
        //19
        inM = 16'b0000000000000000;
        instruction = 16'b1110001100000011;
        reset = 0;
        CLK = 0;
        #50;
        CLK = 1;
        #50;
        //20
        inM = 16'b0000000000000000;
        instruction = 16'b0000000000000000;
        reset = 0;
        CLK = 0;
        #50;
        CLK = 1;
        #50;
        //21
        inM = 16'b0000000000000000;
        instruction = 16'b1110001111011000;
        reset = 0;
        CLK = 0;
        #50;
        CLK = 1;
        #50;
        
        
        // Add stimulus here

    end
      
endmodule
3)	Wave form
 
Figure 11-a. CPU Simulation – final result

 
Figure 11-b. CPU Simulation – full wave

In the beginning of the program reset is called.

We can see that writeM is set to 1 for only 4 times, the same as it is in the program.
7.	Computer Simulation
1)	RAM
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
`timescale 1ns / 1ps

module RAM(in, out, address, load, CLK);
input load;
input [15:0] in;
input [14:0] address;
inout [15:0] out;
input CLK;

reg [15:0] ram[32767:0];

assign out = ram[address];

always @(posedge CLK) 
begin 
     if (load) ram[address] <= in;
end
endmodule
2)	ROM
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
`timescale 1ns / 1ps

module ROM(out, address);

input [14:0] address;
output [15:0] out;

reg [15:0] memory[32767:0];


// note: Decimal number in the bracket
initial begin
    memory[0] = 16'b0000000111110000;
     memory[1] = 16'b1110110000010000;
     memory[2] = 16'b0000000000010000;
     memory[3] = 16'b1110001100001000;
     memory[4] = 16'b0000011000011111;
     memory[5] = 16'b1110110000010000;
     memory[6] = 16'b0000000000010001;
     memory[7] = 16'b1110001100001000;
     memory[8] = 16'b0000111001111001;
     memory[9] = 16'b1110110000010000;
     memory[10] = 16'b0000000000010010;
     memory[11] = 16'b1110001100001000;
     memory[12] = 16'b0000000000010000;
     memory[13] = 16'b1111110000010000;
     memory[14] = 16'b0000000000010001;
     memory[15] = 16'b1111000010010000;
     memory[16] = 16'b0000000000010010;
     memory[17] = 16'b1111010011010000;
     memory[18] = 16'b0000000000011000;
     memory[19] = 16'b1110001100000011;
     memory[20] = 16'b0000000000000000;
     memory[21] = 16'b1110001111011000;
     memory[22] = 16'b0000000000010110;
     memory[23] = 16'b1110101010000111;
     memory[24] = 16'b0000000000000000;
     memory[25] = 16'b1110001100011000;
     memory[26] = 16'b0000000000010110;
     memory[27] = 16'b1110101010000111;
end

assign out = memory[address];

endmodule
The data in the ROM is the program.
3)	Computer HDL code and implementation
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
`timescale 1ns / 1ps

module Computer(reset,CLK);

input CLK,reset;

wire [15:0] outM0,outins,outM;
wire [14:0] addressM,pc;
wire writeM;

CPU cpu1(.inM(outM0),.instruction(outins),.reset(reset),.writeM(writeM),
        .outM(outM),.addressM(addressM),.pc(pc),.CLK(CLK));
RAM ram1(.in(outM),.load(writeM),.address(addressM),.out(outM0),.CLK(CLK));
ROM rom1(.address(pc),.out(outins));

endmodule

 
Figure 12. Micro-Computer design
4)	Simulation
 
Figure 13. Micro-Computer Simulation
As shown in the figure, the result is the same with the CPU simulation, only with unknown outM due to unknown initial value in RAM chip. The end loop is also shown in this figure.
8.	Reference
The design of this CPU is based on nand2tetris.org.



